# Задачи курса АКОС

### phy01-0

> На стандартном потоке ввода подается последовательно вещественное число x и целое число в 16-ричной записи y.
>   Единственным аргументов программы является целое число z в 27-ричной системе исчисления.  
>   Необходимо вывести вычислить значение x+y+z и вывести его на стандартный поток вывода с точностью до 3-го знака после точки. 


### phy01-1
>Реализовать функцию с прототипом:
```
uint16_t satsum(uint16_t x, uint16_t y);
```
>которая выполняет сложение с насыщением, то есть, в случае целочисленного переполнения возвращает максимально возможное целое число для данного типа данных.
>В коде программы запрещено использовать константы, отличные от 0 и 1.
>Запрещено использовать платформо-зависимые или компиляторо-зависимые функции, типы данных с повышенной разрядностью или вещественные типы даннх. 

### phy01-2

>Реализуйте функцию с прототипом:
```
typedef enum {
    PlusZero      = 0x00,
    MinusZero     = 0x01,
    PlusInf       = 0xF0,
    MinusInf      = 0xF1,
    PlusRegular   = 0x10,
    MinusRegular  = 0x11,
    PlusDenormal  = 0x20,
    MinusDenormal = 0x21,
    SignalingNaN  = 0x30,
    QuietNaN      = 0x31
} float_class_t;

extern float_class_t
classify(double *value_ptr);
      
```
>которая классифицирует специальные значения вещественного числа, на которое указывает value_ptr, в соответствии со стандартом IEEE 754.
>При решении допускается использовать только побитовые операции, включая сдвиги.

### phy01-3

>Реализуйте калькулятор выражений над множествами в обратной польской записи.
>На стандартном потоке ввода задается последовательность, состоящая из символов-значений, и символов-операций.
>Значениями являются цифры от 0 до 9, и буквы английского алфавита (заглавные и строчные). Последовательности значений кодируют множества из 62 элементов.
>Операциями являются:

    & - пересечение множеств;
    | - объединение множеств;
    ^ - симметрическая разность;
    ~ - дополнение текущего результата до полного множества.

>В начальный момент времени, множество-результат является пустым. При чтении символов со стандартного потока ввода, когда встречается символ операции, то эта операция применяется к множеству-результату и последнему прочитанному множеству (как в обратной польской записи).
>Вывести на экран полученное итоговое значение множества в нормализованной форме: сначала цифры, затем заглавные буквы, потом - строчные (упорядоченные по алфавиту).
>Для хранения множеств использовать, суммарно, не более 16 байт памяти.

### phy01-4

>Реализуйте функцию с прототипом:
```
extern int
check_int(uint32_t u32); /* retval: 0 - false, 1 - true */
```
>которая проверяет, может ли число u32 быть представлено типом float:
```
float f = u32;
uint64_t y = f;
assert(u32==y);
```
>Функция должна вернуть 1, если число может быть представлено типом float, или 0, - если не может.
>
>Допускается исользовать только побитовые операции.

### phy02-0
>Реализуйте функцию с меткой f, которая вычисляет значение выражения y=Ax2+Bx+C
>Значения A, B, C и x хранятся, соответсвенно, в регистрах r0, r1, r2 и r3.
>Результат вычисления выражения сохраните в регистре r0.
>Все аргументы и значение выражения представимы 32-разрядными знаковыми целыми числами.
>Использовать оперативную память запрещено, - можно использовать только регистры.

### phy02-1


>Реализуйте на языке ассемблера ARM функцию с сигнатурой:
```
int summ(int x0, int N, int *X)
```
>Функция должна вычислять значение x0+∑xi, где 0≤i<N

### phy02-2

>Реализуйте функцию solve, с прототипом
 ```
 int solve(int A, int B, int C, int D);
 ```      
>которая находит минимальное значение x ∈[0,254], которое является одним из корней уравнения: Ax3+Bx2+Cx+D=0.
>Все аргументы и значение выражения представимы 32-разрядными знаковыми целыми числами.
>Не забывайте про сохраняемые регистры; можно использовать для этого память на стеке.
>Гарантируется, что на тестовых данных существует целочисленное решение.

### phy03-0

>Реализуйте функцию calculate, которая вычисляет значение выражения: R=(A*B)+(C*D), где A, B, C, и D - это глобальные переменные типа uint32_t, объявленные во внешнем модуле компиляции, а R, - глобальная переменная типа uint32_t в текущем модуле компиляции.

### phy03-1

>Реализуйте программу, которая вычисляет сумму двух целых десятичных чисел. Размер типа равен размеру машинного слова.
>
>Можно использовать функции стандартной библиотеки языка Си scanf и printf.
>
>В качестве точки входа можно считать функцию main.

### phy03-2

>Напишите программу, которая читает со стандартного потока ввода последовательность символов, и выводит только те из них, которые являются десятичными цифрами от 0 до 9.
>
>Можно использовать функции стандартной библиотеки языка Си: fgetc и fputc.
>
>В качестве точки входа можно считать функцию main.

### phy03-3

>Реализуйте программу, которая считывает символы со стандартного потока ввода, а затем выводит их в обратном порядке.
>
>Можно использовать функции стандартной библиотеки языка Си: fgetc, fputc, realloc и free.
>
>В качестве точки входа можно считать функцию main.

### phy04-0

>Реализуйте функцию на языке ассемблера x86 (IA-32) или x86-64 с сигнатурой:
```
extern void summ(int N, const int *A, const int *B, int *R);
```      

>Функция вычисляет значения Ri=Ai+Bi для всех i от 0 до N.
>
>Память для хранения массива-результата уже выделена.

### phy04-1

>Реализуйте на языке ассемблера x86 (IA-32) или x86-64 функцию с сигнатурой:
```
extern double my_sin(double x)
```
>которая вычисляет значение sin(x).
>
>Запрещено использовать встроенные тригонометрические инструкции.
>
>Для вычислений используйте известный вам из курса Математического анализа способ разложения функции в ряд. Точность результата должна быть маскимально возможной для типа данных double. 

### phy04-2

>Реализуйте функцию на языке ассемблера x86-64 с сигнатурой:
```
exten void mergesort(int from, int to, const int *in, int *out);
```     
>
>Функция выполняет сортировку целых чисел слиянием (Merge Sort).
>
>Параметры from и to - это индексы левой и правой границ областей сортировки; in - исходный массив, out - указатель на выделенную память для хранения результата.
>
>Используйте память только на стеке, использование кучи запрещено.
>
>Для направления ПМФ допускается использование 32-битного ассемблера x86.

### phy04-3

>Реализуйте на языке ассемблера x86 (IA-32) или x86-64 функцию с сигнатурой:
```
extern float dot_product(int N, const float *A, const float *B);
```
>которая вычисляет скалярное произведение векторов A и B.
>
>Гарантируется, что N больше нуля, но не гарантируется, что N кратно четырём.
>
>Значения исходных векторов хранятся в произвольных адресах памяти, поэтому выравнивание для них не гарантируется.
>
>Необходимо минимизировать количество выполняемых вычислительных инструкций, используя векторные вычисления. Доступен набор команд SSE 4.2. Для архитектуры x86-64 также доступен набор команд AVX.

### phy05-0

>Реализуйте на языке ассемблера x86 или x86_64 программу, которая выводит "Hello, World!".
>
>Использование стандартной библиотеки Си запрещено.
>
>Точка входа в программу - функция _start.

### phy05-1

>Реализуйте на языке ассемблера x86_64 программу, которая копирует содержимое со стандартного потока ввода на стандартный поток вывода.
>
>Использование стандартной библиотеки Си запрещено.
>
>Точка входа в программу - функция _start.

### phy05-2

>Реализуйте на языке ассемблера x86_64 программу, которая читает со стандартного потока ввода текст, после чего выводит все строки текста в обратном порядке.
>
>Использование стандартной библиотеки Си запрещено.
>
>Точка входа в программу - функция _start.
####Examples
>Input
```
Мой дядя самых честных правил,
Когда не в шутку занемог,
Он уважать себя заставил
И лучше выдумать не мог.
```      
>Output
```
И лучше выдумать не мог.
Он уважать себя заставил
Когда не в шутку занемог,
Мой дядя самых честных правил,
      
```

### phy06-0

>Программе в аргументах командной строки передаются три имени файла. Первый аргумент - входной файл, два остальных - выходные.
>
>Реализуйте программу, которая читает символы из первого файла, во второй файл записывает только цифры, а в третий - всё остальное.
>
>Разрешается использовать только низкоуровневый ввод-вывод POSIX.
>
>Если входной файл не существует, то нужно завершить работу с кодом 1.
>
>Если не возможно создать один из выходных файлов, то завершить работу с кодом 2.
>
>При возникновении других ошибок ввода-вывода - завершить работу с кодом 3.

### phy06-1

>Программе в аргументе командной строки передается имя файла с бинарными данными в Little-Endian.
>
>Файл хранит внутри себя односвязный список элементов:
```
struct Item {
  int value;
  uint32_t next_pointer;
};
```
>Поле value храние значение элемента списка, поле next_pointer - позицию в файле (в байтах), указывающую на следующий элемент. Признаком последнего элемента является значение next_pointer, равное 0.
>
>Расположение первого элемента списка (если он существует) - строго в нулевой позиции в файле, расположение остальных - случайным образом.
>
>Выведите на экран значения элементов в списке в текстовом представлении.
>
>Для работы с файлом использовать только низкоуровневый ввод-вывод POSIX.

### phy06-2

>Программе на стандартном потоке ввода передаётся список имён файлов.
>
>Необходимо посчитать суммарный размер в байтах всех файлов, которые являются регулярными.

### phy06-3

>Программе на стандартном потоке ввода передаётся список имён файлов.
>
>Если файл является символической ссылкой, то нужно вывести абсолютное имя того файла, на который эта ссылка указывает.
>
>Если файл является регулярным, то необходимо создать символическую ссылку в текущем каталоге, приписав в названии файла префикс link_to_.

### phy07-0

>Программе передаются два аргумента: имя каталога и три целых числа, - год, месяц и день.
>
>Вывести на стандартный поток вывода список имен файлов указанного каталога, которые были модифицированы начиная с указанной даты (по местному часовому поясу).
>

### phy07-1

>Реализуйте программу, которая читает со стандартного потока ввода строки - временные метки в формате:
>
> ```YYYY-MM-DD HH:mm```
>
>Где YYYY - год, MM - месяц, DD - день, HH - час в 24-часовом формате, mm - минуты.
>
>Гарантируется, что ввод содержит не менее двух строк.
>
>На стандартный поток вывода необходимо вывести интервалы времени в минутах, прошедшие между соседними временными метками.
>
>Не забывайте учитывать возможные переводы стрелок зимнего/летнего времени, а также законодательные инициативы по отмене/введению перевода часов на летнее время.

### phy07-2

>Программе в качестве аргумента строки передается имя каталога.
>
>Необходимо посчитать суммарный размер всех регулярных файлов в этом каталоге и во всех вложенных подкаталогах.
>
>Результат вывести на стандартный поток вывода.

### phy07-3

>Реализуйте функцию
```
extern void normalize_path(char * path);
```
>которая обрабатывает строки, представляющие пути к файлам (заканчиваются на любой символ, отличный от /) или каталогам (заканчиваются на символ /).
>
>Функция должна привести текст в каноническую форму:
>
>1. убрать дублирование подряд идущих символов /
>2. обработать фрагменты ./ и ../
>
>Запрещается использовать библиотечные строковые функции.
>
>Запрещается выделять память под новую строку, - используйте уже существующую, аргумент не является константной строкой.
>
>Используйте арифметику указателей.

### phy07-4

>Реализуйте упрощённый аналог команды ls -l.
>
>Программе в качестве первого аргумента передаётся имя каталога.
>
>Необходимо вывести содержимое каталога в виде:
>
```
АТТРИБУТЫ КОЛ_ВО_ССЫЛОК ВЛАДЕЛЕЦ ГРУППА РАЗМЕР ИМЯ
```
>Если в качестве аргумента указано имя файла, то вывести информацию только об этом единственном файле.
>
>Для символических ссылок выведите ещё и имена файлов, на которые они ссылаются.
>
>В случае ошибки - вывести текст ошибки на стандартный поток ошибок и завершить работу с кодом 1.

#####Examples
```
Input

/boot

Output

-rw-r--r-- 1 root root      512 backup_mbr
lrwxrwxrwx 1 root root        1 boot -> .
-rw-r--r-- 1 root root     1725 boot.readme
-rw-r--r-- 1 root root   196482 config-4.12.14-lp150.12.22-default
drwxr-xr-x 6 root root     4096 grub2
lrwxrwxrwx 1 root root       34 initrd -> initrd-4.12.14-lp150.12.22-default
-rw------- 1 root root 11847632 initrd-4.12.14-lp150.12.22-default
-rw-r--r-- 1 root root   182704 memtest.bin
-rw-r--r-- 1 root root   422912 message
-rw-r--r-- 1 root root  1124964 symtypes-4.12.14-lp150.12.22-default.gz
-rw-r--r-- 1 root root   388747 symvers-4.12.14-lp150.12.22-default.gz
-rw-r--r-- 1 root root      484 sysctl.conf-4.12.14-lp150.12.22-default
-rw-r--r-- 1 root root  3474420 System.map-4.12.14-lp150.12.22-default
-rw-r--r-- 1 root root  8028448 vmlinux-4.12.14-lp150.12.22-default.gz
lrwxrwxrwx 1 root root       35 vmlinuz -> vmlinuz-4.12.14-lp150.12.22-default
-rw-r--r-- 1 root root  7057520 vmlinuz-4.12.14-lp150.12.22-default
```      

### phy08-0

>Программе передаются два аргумента: имя файла, и строка для поиска.
>
>Необходимо найти все вхождения строки в текстовом файле, используя отображение на память с помощью системного вызова mmap.
>
>На стандартный поток вывода вывести список всех позиций (с нуля) в файле, где втречаются строка.

### phy08-1

>Программе в аргументе командной строки передается имя файла с бинарными данными в Little-Endian.
>
>Файл хранит внутри себя односвязный список элементов:
```
struct Item {
  int value;
  uint32_t next_pointer;
};
```
>Поле value храние значение элемента списка, поле next_pointer - позицию в файле (в байтах), указывающую на следующий элемент. Признаком последнего элемента является значение next_pointer, равное 0.
>
>Расположение первого элемента списка (если он существует) - строго в нулевой позиции в файле, расположение остальных - случайным образом.
>
>Выведите на экран значения элементов в списке в текстовом представлении.
>
>Используйте отображение содержимого файла на память.

### phy08-2

>Программе передаются три аргумента: имя файла, положительное целое число N - размер квадратной матрицы, и положительное число W - ширина клетки матицы в символах.
>
>Необходимо в указанном файле сформировать текст, который содержит матрицу, состоящую из чисел от 1 до N^2, таким образом, чтобы числа заполняли её по спирали, по часовой стрелке.
>
>Числа должны быть выровнены по правой границе ячейки матрицы.
>
>Используйте mmap для записи в файл.
>
>Можно использовать функции форматного вывода для преобразования числа в строку.
```Examples
Input

N=5, W=5

Output in out.txt

    1    2    3    4    5
   16   17   18   19    6
   15   24   25   20    7
   14   23   22   21    8
   13   12   11   10    9
```

### phy09-0

>Программе передается аргумент - целое число N > 0.
>
>Необходимо создать N-1 дополнительных процессов таким образом, чтобы у каждого процесса было не более одного дочернего процесса.
>
>Каждый из процессов должен вывести на стандартный поток ввода ровно одно число таким образом, чтобы вы выходе получилась строка:
```
1 2 3 4 ... N
```
>Внимание! В этой задаче будет сравнение с учетом пробельных символов. Между числами должен быть ровно один пробел, а завершается строка символом перевода строки.

### phy09-1

>Программе на стандартный поток ввода задается некоторое арифметическое выражение в синтаксисе языка python3.
>
>Необходимо вычислисть это выражение, и вывести результат.
>
>Использовать дополнительные процессы запрещено.

### phy09-2

>На стандартном потоке ввода задается строка текста, которая состоит слова (последовательности непробельных символов), между которыми может быть произвольное количество пробельных символов, включая перевод строки.
>
>Необходимо посчитать количество слов, если известно, что их не больше, чем 255, и вывести это значение на стандартный поток вывода.
>
>Используйте создание новых процессов таким образом, чтобы каждый процесс читал не более одного слова, например, c помощью scanf("%s", ...).
>
>Вывод результата возможен только из того процесса, который запущен самым первым (т.е. из исходной программы).
>
>Итоговая программа должна вернуться с кодом возврата 0.
>
>Размер каждого слова не превышает 4096 байт.

### phy09-3

>Программе на стандартном потоке ввода задается выражение в синтаксисе языка Си.
>
>Необходимо вычислить значение этого выражения (итоговый результат представим типом int) и вывести его на стандартный поток вывода.

### phy10-0

>Реализуйте программу, которая принимает два аргумента: CMD - команда для запуска, IN - имя файла, направляемого на ввод.
>
>Программа должна запускать указанную команду, передавая ей на вход содежимое файла IN.
>
>На стандартный поток вывода вывести количество байт, которое было записано запущенной командой в стандартный поток вывода. Вывод самой команды никуда выводить не нужно.

### phy10-1

>Программе в качестве аргумента передается имя файла программы на языке Си. Необходимо попытаться её скомпилировать с помощью штатного компилятора gcc, после чего вывести на стандартный поток вывода: количество строк программы с ошибками (error), и количество строк программы с предупреждениями (warning). В одной строке может быть найдено несколько ошибок или предупреждений, - нужно вывести именно количество строк.
>
>Запрещено создавать временные файлы для сохранения вывода ошибок компилятора. Используйте передачу текста от компилятора через каналы.

### phy10-2

>Программе передаётся два аргумента: CMD1 и CMD2. Необходимо запустить два процесса, выполняющих эти команды, и перенаправить стандартный поток вывода CMD1 на стандартный поток ввода CMD2.
>
>В командной строке это эквивалентно CMD1 | CMD2.
>
>Родительский процесс должен завершаться самым последним!

### phy10-3

>Программе передаётся произвольное количество аргументов: CMD1, CMD2, ..., CMDN.
>
>Необходимо реализовать эквивалент запуска их командной строки: CMD1 | CMD2 | ... | CMDN.
>
>Родительский процесс должен завершаться самым последним!

### phy10-4

>Программе передаётся произвольное количество аргументов: CMD1, CMD2, ..., CMDN.
>
>Необходимо реализовать эквивалент запуска их командной строки: CMD1 | CMD2 | ... | CMDN.
>
>Родительский процесс должен завершаться самым последним!
>
>В отличие от предыдущей задачи, разрешается использовать **только два канала**. Допускается использовать не более 8 открытых файловых дескрипторов.

### phy11-0
>Программа при запуске сообщает на стандартный поток вывода свой PID, выталкивает буфер вывода с помощью fflush, после чего начинает обрабатывать поступающие сигналы.
>
>При поступлении сигнала SIGTERM необходимо вывести на стандартный поток вывода целое число: количество ранее поступивших сигналов SIGINT и завершить свою работу.
>
>Семантика повединия сигналов (Sys-V или BSD) считается не определенной.

### phy11-1

>Программа при запуске сообщает на стандартный поток вывода свой PID, после чего читает со стандартного потока вывода целое число - начальное значение, которое затем будет изменяться.
>
>При поступлении сигнала SIGUSR1 увеличить текущее значение на 1 и вывести его на стандартный поток вывода.
>
>При поступлении сигнала SIGUSR2 - умножить текущее значение на -1 и вывести его на стандартный поток вывода.
>
>Семантика повединия сигналов (Sys-V или BSD) считается не определенной.
>
>Не забывайте выталкивать буфер вывода.

### phy11-2

>Программе в качестве аргументов передаются N имен текстовых файлов.
>
>Программа должна обрабатывать множество сигналов от SIGRTMIN до SIGRTMAX, причем номер сигнала в диапазоне от SIGRTMIN+1 определяет порядковый номер файла из аргументов:
``` 
 x = signo - SIGRTMIN; // SIGRTMIN <= signo <= SIGRTMAX
                       // 1 <= x <= SIGRTMAX-SIGRTMIN
``` 
>При получении очередного сигнала необходимо прочитать одну строку из определенного файла и вывести её на стандартный поток вывода.
>
>При получении сигнала с номером SIGRTMIN, т.е. при номере аргумента, равным 0, - корректно завершить свою работу с кодом 0.
>
>Все остальные сигналы нужно игнорировать.
>
>Если для вывода используются высокоуровневые функции стандартной библиотеки Си, то необходимо выталкивать буфер обмена после вывода каждой строки.

### phy11-3

>Программа обрабатывать сигнал SIGRTMIN, вместе с которым передается некоторое беззнаковой 32-битное целое число N.
>
>Все остальные сигналы нужно игнорировать.
>
>При получении очередного сигнала нужно уменьшить это число на единицу и отправить его обратно тому процессу, который его послал (используя тот же самый сигнал).
>
>Взаимодействие останавливается при получении значения N==0, после чего нужно корректно завершить работу.
>
>Запрещается использовать signalfd, программа будет компилироваться без поддержки Linux-специфичных расширений.

### phy12-0

>Программе передаются два аргумента: строка с IPv4-адресом в стандартной десятичной записи (четыре числа, разделенные точкой), и номер порта.
>
>Программа должна установить соединение с указанным сервером, после чего читать со стандартного потока ввода целые знаковые числа в текстовом формате, и отправлять их в бинарном виде на сервер. Порядок байт - Little Endian.
>
>В ответ на каждое полученное число, сервер отправляет целое число (в таком же формате), и все эти числа необходимо вывести на стандартный поток вывода в текстовом виде.
>
>Если сервер по своей инициативе закроет соединение, то нужно завершить работу с кодом возврата 0.

### phy12-1

>Необходимо реализовать программу-сервер, которой передаются два аргумента: номер порта и полный путь к каталогу с данными.
>
>Программа должна прослушивать TCP-соединение на сервере localhost и указанным номером порта.
>
>После получения сигнала SIGTERM или SIGINT сервер должен закончить обработку текущего соединения, если оно есть, после чего корректно завершить свою работу.
>
>Внимание: в этой задаче признаком конца строк считается пара символов "\r\n", а не одиночный символ '\n'.
>
>Каждое соединение должно обрабатываться следующим образом:

1. Клиент отправляет строку вида GET ИМЯ_ФАЙЛА HTTP/1.1
2. Клиент отправляет произвольное количество непустых строк
3. Клиент отправляет пустую строку

>После получения пустой строки от клиента, сервер должен отправить клиенту слеющие данные:

1. Строку HTTP/1.1 200 OK, если файл существует, или HTTP/1.1 404 Not Found, если файл не существует, или HTTP/1.1 403 Forbidden, если файл существует, но не доступен для чтения
2. Строку Content-Length: %d, где %d - размер файла в байтах
3. Пустую строку
4. Содержимое файла as-is

>После отправки ответа клиенту, нужно закрыть соединение и не нужно ждать ожидать от клиента следующих запросов.

### phy12-2

>Аргументом программы является целое число - номер порта на сервере localhost.
>
>Программа читает со стандартного потока ввода целые числа в тектовом формате, и отправляет их в бинарном виде (little-endian) на сервер как UDP-сообщение.
>
>В ответ сервер отправляет целое число (также в бинарном виде, little-endian), которое необходимо вывести на стандартный поток вывода.

### phy12-3

>Необходимо реализовать программу-сервер, которой передаются два аргумента: номер порта и полный путь к каталогу с данными.
>
>Программа должна прослушивать TCP-соединение на сервере localhost и указанным номером порта.
>
>После получения сигнала SIGTERM или SIGINT сервер должен закончить обработку текущего соединения, если оно есть, после чего корректно завершить свою работу. Если при этом были запущены дочерние процессы - они должны быть завершены самим сервером.
>
>Внимание: в этой задаче признаком конца строк считается пара символов "\r\n", а не одиночный символ '\n'.
>
>Каждое соединение должно обрабатываться следующим образом:
>
>   1. Клиент отправляет строку вида GET ИМЯ_ФАЙЛА HTTP/1.1
>   2. Клиент отправляет произвольное количество непустых строк
>   3. Клиент отправляет пустую строку
>
>После получения пустой строки от клиента, сервер должен отправить клиенту слеющие данные:
>
>   1. Строку HTTP/1.1 200 OK, если файл существует, или HTTP/1.1 404 Not Found, если файл не существует, или HTTP/1.1 403 Forbidden, если файл существует, но не доступен для чтения
>
>Если файл не является выполняемым, то:
>
>   1. Строку Content-Length: %d, где %d - размер файла в байтах
>   2. Пустую строку
>   3. Содержимое файла as-is
>
>Если файл является выполняемым, то после вывода строки HTTP/1.1 200 OK нужно выполнить этот файл, перенаправив его стандартный поток вывода клиенту as-is.
>
>После отправки ответа клиенту, нужно закрыть соединение и не нужно ждать ожидать от клиента следующих запросов.

### phy13-0

>Реализуйте функцию с сигнатурой:
```
          extern size_t
          read_data_and_count(size_t N, int in[N])
```        

>которая читает данные из файловых дескрипторов in[X] для всех 0 ≤ X < N , и возвращает суммарное количество прочитанных байт из всех файловых дескрипторов.
>
>Скорость операций ввода-вывода у файловых дескрипторов - случайная. Необходимо минимизировать суммарное астрономическое время чтения данных.
>
>По окончании чтения необходимо закрыть все файловые дескрипторы.
>
>Указание: используйте неблокирующий ввод-вывод. Для тестирования можно использовать socketpair.


### phy13-1
>Программе задается единственный аргумент - номер TCP-порта.
>
>Необходимо принимать входящие соединения на TCP/IPv4 для сервера localhost, читать данные от клиентов в текстовом виде, и отправлять их обратно в текстовом виде, заменяя все строчные буквы на заглавные. Все обрабатываемые символы - из кодировки ASCII.
>
>Одновременных подключений может быть много. Использовать несколько потоков или процессов запрещено.
>
>Сервер должен корректно завершать работу при получении сигнала SIGTERM.
>
>Указание: используйте неблокирующий ввод-вывод.
